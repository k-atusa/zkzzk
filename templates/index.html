<!DOCTYPE html>
<html lang="ko">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>치지직 생방송 다운로더</title>
	<!-- Bootstrap CSS -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
	<!-- Bootstrap Icons -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
	<!-- Custom CSS -->
	<style>
		.status-indicator {
			width: 15px;
			height: 15px;
			border-radius: 50%;
			display: inline-block;
			margin-right: 5px;
		}

		.status-live {
			background-color: #28a745;
			animation: pulse 1.5s infinite;
		}

		.status-offline {
			background-color: #6c757d;
		}

		@keyframes pulse {
			0% {
				opacity: 1;
			}

			50% {
				opacity: 0.5;
			}

			100% {
				opacity: 1;
			}
		}

		.streamer-list {
			max-height: 400px;
			overflow-y: auto;
		}
	</style>
</head>

<body>
	<div class="container py-5">
		<div class="row justify-content-center">
			<div class="col-md-8">
				<div class="card shadow mb-4">
					<div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
						<h3 class="mb-0">치지직 생방송 다운로더</h3>
						<button class="btn btn-light" data-bs-toggle="modal" data-bs-target="#settingsModal">
							<i class="bi bi-gear"></i> 설정
						</button>
					</div>
					<div class="card-body">
						<form id="addStreamerForm" class="mb-4">
							<div class="row g-3">
								<div class="col-md-10">
									<label for="channelUrl" class="form-label">치지직 채널 URL</label>
									<input type="url" class="form-control" id="channelUrl" placeholder="https://chzzk.naver.com/..."
										required pattern="https?://chzzk\.naver\.com/.*">
									<div class="form-text">채널 URL을 입력하면 자동으로 스트리머 정보를 가져옵니다.</div>
								</div>
								<div class="col-md-2 d-flex align-items-end">
									<button type="submit" class="btn btn-primary w-100">추가</button>
								</div>
							</div>
						</form>

						<div class="streamer-list">
							<h5 class="mb-3">등록된 스트리머 목록</h5>
							<div id="streamerList" class="list-group">
								{% for streamer in streamers %}
								<div class="list-group-item d-flex justify-content-between align-items-center"
									data-streamer-id="{{ streamer.id }}">
									<div>
										<span class="status-indicator status-offline"></span>
										<span class="streamer-nickname">{{ streamer.nickname }}</span>
										<small class="text-muted d-block">{{ streamer.channel_url }}</small>
										<small class="broadcast-title text-success d-none"></small>
										<small class="download-status text-info d-none"></small>
									</div>
									<div>
										<button class="btn btn-sm btn-danger remove-streamer">
											<i class="bi bi-trash"></i>
										</button>
									</div>
								</div>
								{% endfor %}
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>

	<!-- Settings Modal -->
	<div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel" aria-hidden="true">
		<div class="modal-dialog">
			<div class="modal-content">
				<div class="modal-header">
					<h5 class="modal-title" id="settingsModalLabel">설정</h5>
					<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
				</div>
				<div class="modal-body">
					<form id="settingsForm">
						<div class="mb-3">
							<label for="nidAut" class="form-label">NID_AUT</label>
							<input type="text" class="form-control" id="nidAut"
								placeholder="{{ settings.nid_aut if settings else 'NID_AUT 값을 입력하세요' }}">
						</div>
						<div class="mb-3">
							<label for="nidSes" class="form-label">NID_SES</label>
							<input type="text" class="form-control" id="nidSes"
								placeholder="{{ settings.nid_ses if settings else 'NID_SES 값을 입력하세요' }}">
						</div>
					</form>
				</div>
				<div class="modal-footer">
					<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
					<button type="button" class="btn btn-primary" id="saveSettings">저장</button>
				</div>
			</div>
		</div>
	</div>

	<!-- Bootstrap Bundle with Popper -->
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
	<!-- Custom JavaScript -->
	<script>
		let statusCheckInterval = null;
		let isCheckingEnabled = true;

		// 스트리머 추가
		document.getElementById('addStreamerForm').addEventListener('submit', async (e) => {
			e.preventDefault();
			const channelUrl = document.getElementById('channelUrl').value;

			try {
				const response = await fetch('/add_streamer', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
					},
					body: JSON.stringify({ channel_url: channelUrl })
				});
				const data = await response.json();

				if (data.status === 'success') {
					location.reload(); // 페이지 새로고침
				} else {
					alert(data.message);
				}
			} catch (error) {
				console.error('Error:', error);
				alert('스트리머 추가 중 오류가 발생했습니다.');
			}
		});

		// 스트리머 제거 - 이벤트 위임 사용
		document.getElementById('streamerList').addEventListener('click', async (e) => {
			const removeButton = e.target.closest('.remove-streamer');
			if (!removeButton) return;

			const streamerItem = removeButton.closest('.list-group-item');
			const streamerId = streamerItem.dataset.streamerId;
			const isRecording = streamerItem.querySelector('.download-status').textContent.includes('녹화');

			if (confirm('정말로 이 스트리머를 제거하시겠습니까?')) {
				try {
					// If recording, stop it first
					if (isRecording) {
						const stopResponse = await fetch(`/stop_recording/${streamerId}`, {
							method: 'POST',
							headers: {
								'Content-Type': 'application/json'
							}
						});
						const stopData = await stopResponse.json();
						if (stopData.status !== 'success') {
							alert(stopData.message);
							return;
						}
					}

					// Then remove the streamer
					const response = await fetch(`/remove_streamer/${streamerId}`, {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json'
						}
					});
					const data = await response.json();

					if (data.status === 'success') {
						streamerItem.remove();
					} else {
						alert(data.message);
					}
				} catch (error) {
					console.error('Error:', error);
					alert('스트리머 제거 중 오류가 발생했습니다.');
				}
			}
		});

		// 주기적으로 방송 상태 확인
		async function checkStreamerStatus() {
			if (!isCheckingEnabled) return;

			const streamerItems = document.querySelectorAll('.list-group-item');
			if (streamerItems.length === 0) return;

			for (const item of streamerItems) {
				const channelUrl = item.querySelector('.text-muted').textContent;
				const statusIndicator = item.querySelector('.status-indicator');
				const nickname = item.querySelector('.streamer-nickname');
				const broadcastTitle = item.querySelector('.broadcast-title');
				const downloadStatus = item.querySelector('.download-status');

				try {
					const response = await fetch('/check_status', {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify({ channel_url: channelUrl })
					});
					const data = await response.json();

					if (data.status === 'error') {
						if (data.error_code === 'missing_cookies') {
							alert(data.message);
							// Open settings modal
							const settingsModal = new bootstrap.Modal(document.getElementById('settingsModal'));
							settingsModal.show();
							// Stop checking status
							isCheckingEnabled = false;
							if (statusCheckInterval) {
								clearInterval(statusCheckInterval);
								statusCheckInterval = null;
							}
							return;
						}
						console.error('Error:', data.message);
						continue;
					}

					if (data.is_live) {
						statusIndicator.className = 'status-indicator status-live';
						nickname.style.color = '#28a745';
						
						// Show broadcast title
						if (data.broadcast_title) {
							broadcastTitle.textContent = `방송 제목: ${data.broadcast_title}`;
							broadcastTitle.classList.remove('d-none');
						}
						
						// Show recording status
						if (data.is_recording) {
							downloadStatus.textContent = '녹화 중...';
							downloadStatus.classList.remove('d-none');
						} else if (data.download_started) {
							downloadStatus.textContent = '녹화 시작 중...';
							downloadStatus.classList.remove('d-none');
						} else {
							downloadStatus.classList.add('d-none');
						}
					} else {
						statusIndicator.className = 'status-indicator status-offline';
						nickname.style.color = '';
						broadcastTitle.classList.add('d-none');
						downloadStatus.classList.add('d-none');
					}
				} catch (error) {
					console.error('Error:', error);
				}
			}
		}

		// 설정 저장
		document.getElementById('saveSettings').addEventListener('click', async () => {
			const nidAut = document.getElementById('nidAut').value;
			const nidSes = document.getElementById('nidSes').value;

			try {
				const response = await fetch('/settings', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
					},
					body: JSON.stringify({
						nid_aut: nidAut,
						nid_ses: nidSes
					})
				});
				const data = await response.json();

				if (data.status === 'success') {
					alert('설정이 저장되었습니다.');
					const modal = bootstrap.Modal.getInstance(document.getElementById('settingsModal'));
					modal.hide();
					
					// Resume status checking if it was stopped
					if (!isCheckingEnabled) {
						isCheckingEnabled = true;
						// Start checking immediately
						checkStreamerStatus();
						// Then set up the interval
						statusCheckInterval = setInterval(checkStreamerStatus, 30000);
					}
				} else {
					alert(data.message);
				}
			} catch (error) {
				console.error('Error:', error);
				alert('설정 저장 중 오류가 발생했습니다.');
			}
		});

		// 설정 모달이 열릴 때 현재 설정값 로드
		document.getElementById('settingsModal').addEventListener('show.bs.modal', async () => {
			try {
				const response = await fetch('/settings');
				const data = await response.json();

				document.getElementById('nidAut').value = data.nid_aut;
				document.getElementById('nidSes').value = data.nid_ses;
			} catch (error) {
				console.error('Error:', error);
			}
		});

		// Start status checking
		statusCheckInterval = setInterval(checkStreamerStatus, 30000);
		// Initial check
		checkStreamerStatus();
	</script>
</body>

</html>